{"meta":{"title":"wtpuuu","subtitle":null,"description":null,"author":"wtpuuu","url":"http://puuuuuu.github.io"},"pages":[],"posts":[{"title":"MySQL数据库基本操作","slug":"mysql_command","date":"2018-05-19T15:29:53.000Z","updated":"2018-05-26T06:09:46.974Z","comments":true,"path":"2018/05/19/mysql_command/","link":"","permalink":"http://puuuuuu.github.io/2018/05/19/mysql_command/","excerpt":"","text":"建表、删表、记录的增删改查等基本操作建表 - create table table_name(列(字段)) 添加列(字段) - alter table table_name add column field_name … 删除列(列) - alter table table_name drop column field_name 插入记录 - insert into table_name values(记录) 删除记录 - delete from table_name where 位置(最好是主键id) 更新记录 - update table_name set 记录 where 位置 查询记录 - select 字段名 from table_name where 筛选条件 筛选条件之模糊查询 - likeex： where name like ‘杨%’ - % 通配符 where name like ‘%杨%’ where name like ‘杨_’ - _通配符 where name like ‘杨__’ 聚合函数 max() - 求最大值 min() - 求最小值 avg() - 求平均值 count() - 计数 sum() - 求和 特有函数 now() - 返回当前系统日期和时间 if() if( expr1, expr2 , expr3 ) expr1 的值为 TRUE，则返回值为 expr2 expr1 的值为FALSE，则返回值为 expr3 排序语法：order by 字段名 字段名后不跟参数或者跟sec或者SQL语句中不跟order by语句是默认按升序排序 字段名后可以更参数desc为降序排序 order by null可以消除SQL语句的默认排序行为 分组查询语法：group by 字段名 连接查询 连接查询 - select 字段名1,字段名2 from table_name1,table_name2 where 表与表之间的关联条件 内连接 - select 字段名1,字段名2 from table_name1 别名1 inner join table_name2 别名2 where 表与表之间的关联条件 左外连接 - select 字段名1,字段名2 from table_name1 别名1 left join table_name2 别名2 where 表与表之间的关联条件 作用 - 左表(写在前面的表)不满足连表条件的记录也要查询出来 右外链接 - select 字段名1,字段名2 from table_name1 别名1 right join table_name2 别名2 where 表与表之间的关联条件 作用 - 与左外连接一样，右表(写在后面的表)不满足连表条件的记录也要查询出来 分页查询语法1 - limit N 作用：查询前N条记录 语法2 - limit N1,N2 作用：查询从第N1+1条开始的N2条记录 用户操作– 创建用户并指定登录口令 create user user_name identified by ‘password‘; – 修改指定用户登录口令 alter user user_name identified by ‘password‘; – 授予权限和召回权限(grant 授予权限/revoke 召回权限)grant all on database_name.table_name to user_name ; revoke all on database_name.table_name from user_name ; grant select on database_name.table_name to user_name ; grant all on database_name.* to user_name ; grant all on . to ‘user_name ‘@’%’; revoke all on . from user_name ; – 删除用户 drop user user_name ;","categories":[],"tags":[{"name":"数据库","slug":"数据库","permalink":"http://puuuuuu.github.io/tags/数据库/"}]},{"title":"Python IDLE配置清屏快捷键(Ctrl+L)","slug":"Python IDLE配置清屏快捷键(Ctrl+L)","date":"2018-05-14T15:29:53.000Z","updated":"2018-05-26T05:42:02.855Z","comments":true,"path":"2018/05/14/Python IDLE配置清屏快捷键(Ctrl+L)/","link":"","permalink":"http://puuuuuu.github.io/2018/05/14/Python IDLE配置清屏快捷键(Ctrl+L)/","excerpt":"","text":"Python IDLE配置清屏快捷键(Ctrl+L)1.在Python\\Lib\\idlelib下，新建一个ClearWindow.py文件（没有时就新建），并将如下代码粘贴进去： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class ClearWindow: menudefs = [ ('options', [None, ('Clear Shell Window', '&lt;&lt;clear-window&gt;&gt;'), ]),] def __init__(self, editwin): self.editwin = editwin self.text = self.editwin.text self.text.bind(\"&lt;&lt;clear-window&gt;&gt;\", self.clear_window2) self.text.bind(\"&lt;&lt;undo&gt;&gt;\", self.undo_event) # add=\"+\" doesn't work def undo_event(self, event): text = self.text text.mark_set(\"iomark2\", \"iomark\") text.mark_set(\"insert2\", \"insert\") self.editwin.undo.undo_event(event) # fix iomark and insert text.mark_set(\"iomark\", \"iomark2\") text.mark_set(\"insert\", \"insert2\") text.mark_unset(\"iomark2\") text.mark_unset(\"insert2\") def clear_window2(self, event): # Alternative method # work around the ModifiedUndoDelegator text = self.text text.undo_block_start() text.mark_set(\"iomark2\", \"iomark\") text.mark_set(\"iomark\", 1.0) text.delete(1.0, \"iomark2 linestart\") text.mark_set(\"iomark\", \"iomark2\") text.mark_unset(\"iomark2\") text.undo_block_stop() if self.text.compare('insert', '&lt;', 'iomark'): self.text.mark_set('insert', 'end-1c') self.editwin.set_line_and_column() def clear_window(self, event): # remove undo delegator undo = self.editwin.undo self.editwin.per.removefilter(undo) # clear the window, but preserve current command self.text.delete(1.0, \"iomark linestart\") if self.text.compare('insert', '&lt;', 'iomark'): self.text.mark_set('insert', 'end-1c') self.editwin.set_line_and_column() # restore undo delegator self.editwin.per.insertfilter(undo) 2.Python\\Lib\\idlelib下修改config-extensions.def ，在末尾添加如下内容： 123456[ClearWindow]enable=1enable_editor=0enable_shell=1[ClearWindow_cfgBindings]clear-window=&lt;Control-Key-l&gt; 3.重启Python的IDLE，在options选项中就可以看到增加了Clear shell Window Ctrl+L，即清屏的快捷键为：Ctrl+L","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://puuuuuu.github.io/tags/Python/"}]},{"title":"python cookbook(第3版)笔记","slug":"python cookbook(第3版)笔记","date":"2018-05-14T15:29:53.000Z","updated":"2018-05-26T06:06:30.782Z","comments":true,"path":"2018/05/14/python cookbook(第3版)笔记/","link":"","permalink":"http://puuuuuu.github.io/2018/05/14/python cookbook(第3版)笔记/","excerpt":"","text":"第一章 数据结构和算法解压序列赋值给多个变量 序列元素的数量必须跟变量数一致,否则会产生异常，这种解压赋值可以用在任何可迭代对象上。 1234567&gt;&gt;&gt; p = (4, 5)&gt;&gt;&gt; x, y, z = pTraceback (most recent call last): File \"&lt;pyshell#1&gt;\", line 1, in &lt;module&gt; x, y, z = pValueError: not enough values to unpack (expected 3, got 2)&gt;&gt;&gt; 1.2 解压可迭代对象赋值给多个变量与*表达式的结合 123456&gt;&gt;&gt; *trailing, current = [10, 8, 7, 1, 9, 5, 10, 3]&gt;&gt;&gt; current3&gt;&gt;&gt; trailing[10, 8, 7, 1, 9, 5, 10]&gt;&gt;&gt; 星号表达式与字符串的分割 1234567891011&gt;&gt;&gt; line = 'nobody:*:-2:-2:UnprivilegedUser:/var/empty:/usr/bin/false'&gt;&gt;&gt; uname, *fields, homedir, sh = line.split(':')&gt;&gt;&gt; uname'nobody'&gt;&gt;&gt; homedir'/var/empty'&gt;&gt;&gt; sh'/usr/bin/false'&gt;&gt;&gt; fields['*', '-2', '-2', 'UnprivilegedUser']&gt;&gt;&gt; 星号表达式实现递归算法 123456789101112&gt;&gt;&gt; items = [1, 2, 3, 5, 11, 55, 9]&gt;&gt;&gt; head, *tail = items&gt;&gt;&gt; head1&gt;&gt;&gt; tail[2, 3, 5, 11, 55, 9]&gt;&gt;&gt; def sum(items): head, *tail = items return head + sum(tail) if tail else head&gt;&gt;&gt; sum(items)86&gt;&gt;&gt; 1.3 保留最后N个元素 collections中deque(maxlen=N)函数的用法：使用该函数时，构造函数会新建一个固定大小的队列，当新的元素加入并且队列已满的时候，最老的元素会自动被移除掉。 12345678910&gt;&gt;&gt; q = deque(maxlen=3)&gt;&gt;&gt; q.append(1)&gt;&gt;&gt; q.append(2)&gt;&gt;&gt; q.append(3)&gt;&gt;&gt; qdeque([1, 2, 3], maxlen=3)&gt;&gt;&gt; q.append(4)&gt;&gt;&gt; qdeque([2, 3, 4], maxlen=3)&gt;&gt;&gt; ex:文本匹配 12345678910111213141516171819202122from collections import dequedef search(lines, pattern, history=5): previous_lines = deque(maxlen=history) for li in lines: if pattern in li: yield li, previous_lines previous_lines.append(li)def main(): with open(r'./note.txt',encoding='gbk') as f: for line, prevlines in search(f, 'python', 5): for pline in prevlines: print(pline, end='') print(line, end='') print('-' * 20)if __name__ == '__main__': main() 1.4 查找最大或最小的N个元素 heapq模块中的nlargest()和nsmallest可以解决这个问题；如果你仅仅想查找唯一的最小或者最大(N=1)的元素，用min()和max()函数会更快些；类似的，如果N的大小和集合的大小接近的时候，通常先排序这个集合，然后用切片的操作更快点sorted(items)[:N]或者sorted(items)[-N:]，sorted函数可以理解为items列表使用列表的内建函数items.sort()后得到排序后新的列表再进行切片操作。 ex1: 1234567&gt;&gt;&gt; import heapq&gt;&gt;&gt; nums = [1, 2, 4, 6, 7, 22, 8, 11, 17, 99, 121, 122, 100]&gt;&gt;&gt; heapq.nlargest(3, nums) # nlargest求指定集合nums中最大的3个元素的列表[122, 121, 100]&gt;&gt;&gt; heapq.nsmallest(4, nums) # nsmallest求指定集合nums中最小的4个元素的列表[1, 2, 4, 6]&gt;&gt;&gt; ex2: 123456789101112&gt;&gt;&gt; nums = [2,1, 4, 5, 8, 22, 44, 43, 45, 65, 23, 66]&gt;&gt;&gt; import heapq&gt;&gt;&gt; heapq.heapify(nums) # 将nums列表进行排序&gt;&gt;&gt; nums[1, 2, 4, 5, 8, 22, 44, 43, 45, 65, 23, 66]&gt;&gt;&gt; heapq.heappop(nums) # 弹出nums列表的第一个元素即最小的元素1&gt;&gt;&gt; heapq.heappop(nums)2&gt;&gt;&gt; heapq.heappop(nums)4&gt;&gt;&gt; 1.5 实现一个优先级队列","categories":[],"tags":[{"name":"Python","slug":"Python","permalink":"http://puuuuuu.github.io/tags/Python/"}]}]}